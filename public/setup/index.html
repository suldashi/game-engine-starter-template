<!doctype html>
<html>
<head>
	<link rel="stylesheet" type="text/css" target="_blank" href="../style.css">
</head>
<body>
	<div id="pixi-container"></div>
	<article>
		<h1>Lesson 0 - Intro</h1>
		<h3>In this article we will be setting up the infrastructure to build the JavaScript file that will be served to the players, the main game loop, and the capability to draw things on the screen.</h3>
		<h4>Setting up the tools</h4>
		<p>
			In a web browser context, all JavaScript code that needs to be executed by the end user must ultimately be served through a <code>&lt;script&gt; tag.</code>
			While making our game, eventually we will have to split our code into multiple files, and it's not viable to use <code>script</code> tags for each of them.
			This makes it necessary to have a build (or bundling) step, where all of our small JavaScript files are merged into a single file, which is then served to our players.
		</p>
		<p>
			We'll be using <a target="_blank" href="http://browserify.org/">Browserify</a> and <a target="_blank" href="https://gulpjs.com/">Gulp</a> to do the code bundling.
			These programs run in a <a target="_blank" href="https://nodejs.org">Node.js</a> context, so we'll need to install Node.js to use them.
			After installing Node.js and initializing a project, we install Browserify and Gulp using the following command: <code class="codeblock">npm install --save-dev gulp browserify vinyl-source-stream vinyl-buffer</code>
			Also, we'll need to install Gulp globally in our system using the following command: <code class="codeblock">npm install -g gulp-cli</code>
			You may have noticed that we also installed <code>vinyl-buffer</code> and <code>vinyl-source-stream</code>. They are used by Browserify to manipulate files and streams.
		</p>
		<p>
			We'll also need a web server to host the game. 
			<a target="_blank" href="https://expressjs.com/">Express</a> is by far the most popular Node.js web server, so we'll install that by running the following command: <code class="codeblock">npm install --save express</code>
		</p>
		<h4>Project directory structure</h4>
		<p>
			Our project has three primary directories: <code>app</code>, <code>public</code>, and <code>src</code>. We'll need to create them all.
		</p>
		<p>
			The <code>app</code> directory is used to host the Node.js web server that will serve our HTML and JS files during development.
			In the <code>app</code> directory, we'll create a file, <code>index.js</code>, and place the following code there:
			<pre class="codeblock">
const express = require('express');
const app = express();
const server = require('http').createServer(app);
const path = require('path');

const port = 8080;

app.use('/public', express.static(path.resolve(__dirname,'..','public')));

app.get('/', (req,res) => {
	res.redirect('/public');
});

server.listen(port);
console.log('started on ' + port);</pre>
		</p>
		<p>
			The <code>public</code> directory is used to host the files that will be served by the web server.
			Let's create an <code>index.html</code> file in there, and put the following code in there:
			<pre class="codeblock">
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;Made using the MVP engine&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;div&gt;Hello game&lt;/div&gt;
	&lt;script src="/public/js/engine.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
			Pay particular attention to the <code>&lt;script&gt;</code> tag, which is referencing a file in the <code>public</code> directory which does not exist yet.
			This is the bundle file that will be generated by Gulp and Browserfiy, so we don't have to create it now.
		</p>
		<p>
			Finally, the <code>src</code> directory is used to store our game engine JS files. 
			The entry point of the game will be the <code>engine.js</code> file, and it serves a similar role to <code>main()</code> function in C++, Java, and C#.
			We'll create the <code>engine.js</code> file, place it in the <code>src</code> directory, and put the following code there: 
			<code class="codeblock">console.log("hello game");</code>
			The files in this directory will not be served directly by the game server, but will be bundled together using Gulp and Browserify.
			The resulting bundle file will be placed in the <code>public</code> directory, and will contain the entire game in a single file.
		</p>
		<h4>Running Gulp and building our game</h4>
		<p>
			Gulp is used to run various maintenance tasks in a project, and in our case we'll use it to bundle our game engine into a single file.
			The tasks are defined in a file called <code>gulpfile.js</code>, so let's create it and place it in the root directory of our project.
			Let's place the following code in there:
			<pre class="codeblock">
const gulp = require('gulp');
const browserify = require('browserify');
const buffer = require('vinyl-buffer');
const source = require('vinyl-source-stream');

function bundle() {
	return browserify({entries:`src/engine.js`})
		.bundle()
		.pipe(source("engine.js"))
		.pipe(buffer())
		.pipe(gulp.dest(`public/js`));
}

function watch() {
	return gulp.watch("src/**/*.js", gulp.series("default"));
}

gulp.task("default", bundle);
gulp.task("watch", watch);</pre>
		</p>
		<p>
			There are two tasks in the gulpfile, <code>default</code> and <code>watch</code>.
		</p>
		<p>
			The <code>default</code> task runs Browserify on the <code>src/engine.js</code> file, bundles any other files used by it (none at the moment), and places the resulting file in the <code>public/js/engine.js</code> file.
		</p>
		<p>
			The <code>watch</code> task keeps track of the JS files inside the <code>src</code> directory, then runs the <code>default</code> task if it detects any changes.
			It's very handy since we don't have to run Gulp every time we want to make a bundle, but the bundle will be made on any change of the code.
		</p>
		<p>
			Let's try to make a bundle right now. To run the <code>default</code> task, type the following command in the terminal:
			<code class="codeblock">gulp</code>
			The output should look something like this:
			<img class="screenshot" src="img/gulp.png"/>
			Notice the new file in the <code>public/js</code> directory. This file is the bundled engine, and it was created by Gulp and Browserify.
		</p>
		<p>
			We have everything we need to test our development pipeline. Go ahead and run the web server using the following command:
			<code class="codeblock">node app/index.js</code>
			Then, navigate to <code>http://localhost:8080</code> using your browser, and open the development console.
			If everything worked correctly, you should see this message there:
			<img class="screenshot" src="img/console.png"/>
			At this point, your project directory should look something like this:
			<img class="screenshot" src="img/dir.png" />
		</p>
		<h4>The game loop</h4>
		<p>
			The <a target="_blank" href="https://gameprogrammingpatterns.com/game-loop.html">game loop (or main loop)</a> is the heart of a video game, and it gives the video game a sense of progress over time.
			Essentially, the game loop can be thought as an infinite loop that runs at a steady state instead of as fast as it can.
			The primary function of a game loop is to gather user input, advance the game by a small amount, display the results to the user, and repeat this forever.
		</p>
		<p>
			As mentioned before, the game loop runs at a constant rate. One execution of the game loop is called a frame (or tick), and the time between two frames is called a timestep (or delta).
			To make the game simulation consistent, the game loop runs at a fixed timestep, even if the input and rendering may run at a different and variable timestep.
			A timestep of 16.6666ms would run the game loop 60 times per second, or 60 FPS. 
		</p>
		<p>
			Because programming a game loop is quite complicated, we won't make our own, but we'll use a library called <a target="_blank" href="https://github.com/IceCreamYou/MainLoop.js">mainloop.js</a>.
			To install it, run the following command:
			<code class="codeblock">npm install --save mainloop.js</code>
		</p>
		<p>
			Including the mainloop.js library in our engine is very easy, all we have to do is use the <code>require()</code> function at the top of our <code>engine.js</code> file, exactly the same as in Node.js.
			A small example of how a working game loop would look is presented here:
			<pre class="codeblock">
const MainLoop = require("mainloop.js");

let loopCounter = 0;

MainLoop.setUpdate(() => {
	console.log("The game loop has been executed " + loopCounter + " times.");
	loopCounter++;
}).start();</pre>
			Save this code to the <code>engine.js</code> file, run <code>gulp</code> to build the game, and navigate to <code>http://localhost:8080</code> to see it in action.
			Open the development console, and if it looks something like this, it means the game loop is running successfully:
			<img class="screenshot" src="img/gameloop.png" />
		</p>
		<p>
			Note the <code>setUpdate()</code> function. The callback here is the heart of the game loop, and this function runs every frame.
			The entire game world is simulated in this function, including physics, AI, game rules, and most other systems that make up a video game.
		</p>
		<h4>Setting up PixiJS</h4>
		<p>
			Almost all video games need some sort of visual display, and ours will be no different. 
			Just like the game loop, programming an entire graphical system is very complicated, so we'll use a library called <a href="https://www.pixijs.com/">PixiJS</a>.
			Install PixiJS using this command:
			<code class="codeblock">npm install --save pixi.js</code>
		</p>
		<p>
			Before adding PixiJS to our game, we must first add a container element in our <code>public/index.html</code> file.
			PixiJS draws the graphics in an HTML <code>&lt;canvas&gt;</code> element, so this canvas will need to be attached to this container.
			We'll give this container a prominent ID, and it should look something like this:
			<pre class="codeblock">
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;Made using the MVP engine&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;div id="pixi-container"&gt;&lt;/div&gt;>
	&lt;script src="/public/js/engine.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
		</p>
		<p>
			Now that the PixiJS container exists, we can go ahead and add the PixiJS code to our game, in the <code>src/engine.js</code> file.
			It should look something like this:
			<pre class="codeblock">
const MainLoop = require("mainloop.js");
const PIXI = require("pixi.js");

let pixiApp = new PIXI.Application({antialias: true});
let pixiContainer = document.getElementById("pixi-container");
pixiContainer.appendChild(pixiApp.view);

let loopCounter = 0;

MainLoop.setUpdate(() => {
	console.log("The game loop has been executed " + loopCounter + " times.");
	loopCounter++;
}).start();
			</pre>
			After building the game and refreshing the page, you should see a black rectangle, which is the default PixiJS background color.
			We can also inspect the page using the browser's development tools, and it should look something like this:
			<img class="screenshot" src="img/pixi.png" />
		</p>
		<h4>Drawing things on the screen with PixiJS</h4>
		<p>
			Let's draw something a bit more interesting than a black screen.
		</p>
		<p>
			One of the features of PixiJS is the ability to draw primitive shapes, such as lines, circles, rectangles, and other polygons.
			This is done using the <code>PIXI.graphics</code> class, and all we have to do is make an instance of that class and attach it to the default PixiJS stage.
			Here's how our <code>engine.js</code> file would look like:
			<pre class="codeblock">
const MainLoop = require("mainloop.js");
const PIXI = require("pixi.js");

let pixiApp = new PIXI.Application({antialias: true});
let pixiContainer = document.getElementById("pixi-container");
let pixiGraphics = new PIXI.Graphics();
pixiApp.stage.addChild(pixiGraphics);
pixiContainer.appendChild(pixiApp.view);

let loopCounter = 0;

MainLoop.setUpdate(() => {
	console.log("The game loop has been executed " + loopCounter + " times.");
	loopCounter++;
}).start();
			</pre>
			If the browser console is not giving out any errors, we've successfully added the graphics object to PixiJS.
		</p>
		<p>
			Drawing using the <code>PIXI.graphics</code> class is quite easy. Let's draw a triangle and examine the details:
			<pre class="codeblock">
pixiGraphics.beginFill(0x00FF00);
pixiGraphics.drawPolygon([60,70,190,50,40,200]);
pixiGraphics.endFill();
			</pre>
			We should see a green triangle on the black canvas.
		</p>
		<p>
			Notice the three methods, <code>beginFill()</code>, <code>drawPolygon()</code>, and <code>endFill()</code>.
		</p>
		<p>
			<code>beginFill()</code> initializes the <code>PIXI.graphics</code> drawing method, and also sets the fill color of the drawn shape.
			In our case, the first parameter of <code>beginFill()</code> is a hexadecimal code representing the color green in the RGB color space.
		</p>
		<p>
			<code>drawPolygon()</code> is responsible for actually drawing the triangle on the screen. It's accepts an array of numbers as an argument.
			These numbers are the coordinates of the vertices of the triangle, and are ordered such that the first element of the array is the x coordinate of the first point,
			the second element is the y coordinate of the first point, the third element is the x coordinate of the second point, and so on.
			<img class="screenshot" src="img/coords.png" />
		</p>
		<p>
			<code>endFill()</code> finishes drawing the polygon. This function is needed so that subsequent calls to <code>beginFill()</code> will draw other polygons instead of continuing the current polygon.
		</p>
		<p>
			The final version of the <code>engine.js</code> file should look like this:
			<pre class="codeblock">
const MainLoop = require("mainloop.js");
const PIXI = require("pixi.js");

let pixiApp = new PIXI.Application({antialias: true});
let pixiContainer = document.getElementById("pixi-container");
let pixiGraphics = new PIXI.Graphics();
pixiGraphics.beginFill(0x00FF00);
pixiGraphics.drawPolygon([60,70,190,50,40,200]);
pixiGraphics.endFill();
pixiApp.stage.addChild(pixiGraphics);
pixiContainer.appendChild(pixiApp.view);

let loopCounter = 0;

MainLoop.setUpdate(() => {
	console.log("The game loop has been executed " + loopCounter + " times.");
	loopCounter++;
}).start();
			</pre>
		</p>
		<h4>Conclusion</h4>
		<p>
			The web and JavaScript hold great promise as gaming platforms. 
			The ability to distribute games and updates just by sharing a link is unmatched by any platform, and is the reason for the web's dominance in business and productivity apps.
			I hope to show that the same capability is present in web games as well, and that JavaScript is mature enough to be not just a teaching tool, but a primary development language for games.
		</p>
	</article>
	<script src="js/engine.js"></script>
</body>
</html>